const path = require('path');

const criterias = {
    type: 'TYPE',
    pattern: 'PATTERN',
    minSize: 'MIN-SIZE',
    maxSize: 'MAX-SIZE'
};

const typeCriteria = (stats, type) => {
    return stats.type === type;
};

const patternCriteria = (stats, pattern) => {
    return path.basename(stats.path).match(new RegExp(pattern));
};

const convertByteSize = (size, unit) => {
    const sizeUnit = {
        B: 1,
        K: 1024,
        M: 1048576,
        G: 1073741824
    };

    return size / sizeUnit[unit];
};

const sizeFromCriteriaValue = (value) => {
    return {
        unit: value.slice(value.length - 1, value.length),
        value: value.slice(0, value.length - 1)
    }
};

const minSizeCriteria = (stats, value) => {
    const size = sizeFromCriteriaValue(value);

    return convertByteSize(stats.size, size.unit) >= size.value;
};

const maxSizeCriteria = (stats, value) => {
    const size = sizeFromCriteriaValue(value);

    return convertByteSize(stats.size, size.unit) <= size.value;
};

const criteriaCallback = {
    'TYPE': typeCriteria,
    'PATTERN': patternCriteria,
    'MIN-SIZE': minSizeCriteria,
    'MAX-SIZE': maxSizeCriteria,
};

const criteria = (name, value) => {
    return {
        name: name,
        value: value,
        callback: criteriaCallback[name]
    };
};

const criteriaName = (arg) => arg.split('=')[0].slice(2);
const criteriaValue = (arg) => arg.split('=')[1];

module.exports = {

    normalize: (criterias) => {
        const isTypeDirCriteriaExist = (criterias) => {
            return !!criterias.find(criteria => criteria.name === 'TYPE' && criteria.value === 'D');
        };

        const removeSizeCriterias = (criterias) => {
            return criterias.filter(criteria => criteria.name !== 'MIN-SIZE' && criteria.name !== 'MAX-SIZE');
        };

        if (criterias) {
            return isTypeDirCriteriaExist(criterias) ? removeSizeCriterias(criterias) : criterias;
        }

        return [];
    },

    argvCriterias: (argv) => {
        const criteriaExist = (criteriaName) => Object.keys(criteriaCallback).indexOf(criteriaName) >= 0;
        const args = argv.slice(2).filter(arg => criteriaExist(criteriaName(arg)));

        return args.map(arg => criteria(criteriaName(arg), criteriaValue(arg)));
    },

    argvDir: (argv) => {
        const dirCriteriaName = 'DIR';
        const dirArg = argv.slice(2).find(arg => criteria(criteriaName(arg), criteriaValue(arg)).name === dirCriteriaName);

        return dirArg ? criteriaValue(dirArg) : null;
    },

    type: (type) => criteria(criterias.type, type),

    pattern: (pattern) => criteria(criterias.pattern, pattern),

    minSize: (size) => criteria(criterias.minSize, size),

    maxSize: (size) => criteria(criterias.maxSize, size)

};