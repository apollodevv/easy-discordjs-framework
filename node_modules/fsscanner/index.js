const fs = require('fs');
const path = require('path');
const criteria = require('./criteria');

const scanResultType = {
    file: 'F',
    dir: 'D'
};

const scanDir = (dir, callback) => {
    fs.readdir(dir, (err, files) => {
        if (err) {
            callback(err, null);
        } else {
            const result = [];
            if (files && files.length > 0) {
                let processed = 0;
                files.map(file => fs.lstat(path.join(dir, file), (err, stats) => {
                    if (err) {
                        console.log(err);
                    } else if(stats.isFile() || stats.isDirectory()) {
                        result.push({
                            path: path.join(dir, file),
                            type: stats.isFile() ? scanResultType.file : scanResultType.dir,
                            size: stats.size
                        });
                    }

                    processed++;
                    if (processed === files.length) {
                        callback(null, result)
                    }
                }));
            } else {
                callback(null, []);
            }
        }
    });
};

const fsScan = (dir, criterias, callback) => {

    const criteriasFilter = (results) => {
        return results.filter(result => criterias.every(criteria => criteria.callback(result, criteria.value)));
    };

    scanDir(dir, (err, scanResults) => {
        if (err) {
            callback(err, null);
        } else {
            const dirs = scanResults.filter(result => result.type === scanResultType.dir);
            if (dirs && dirs.length > 0) {
                const dirsResults = [];
                let processedDirs = 0;
                dirs.map(dir1 => fsScan(dir1.path, criterias, (err, results) => {
                    if (err) {
                        callback(err, null);
                    } else {
                        processedDirs++;
                        dirsResults.push(...results);
                        if (processedDirs === dirs.length) {
                            callback(null, criteriasFilter(scanResults.concat(dirsResults)));
                        }
                    }
                }));
            } else {
                callback(null, criteriasFilter(scanResults));
            }
        }
    });
};

module.exports = {

    scan: (dir, criterias, callback) => {
        if(dir) {
            fsScan(path.normalize(dir), criteria.normalize(criterias), (err, results) => {
                if (err) {
                    callback(err, null);
                } else {
                    callback(null, results.map(result => result.path));
                }
            });
        } else {
           throw Error('Invalid required parameter dir');
        }
    },

    argvCriterias: (argv) => {
        return criteria.argvCriterias(argv);
    },

    argvDir: (argv) => {
        return criteria.argvDir(argv);
    },

    criteria: {
        type: (type) => criteria.type(type),
        pattern: (pattern) => criteria.pattern(pattern),
        minSize: (size) => criteria.minSize(size),
        maxSize: (size) => criteria.maxSize(size)
    }
};